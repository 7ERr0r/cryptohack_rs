use crate::big;
use num_bigint::BigInt;

pub fn a_modular_math_quadratic_residues() {
    let p = 29;
    let ints = [14, 6, 11];

    for a in 0..p {
        let aa = (a * a) % p;
        if ints.contains(&aa) {
            println!("\nquadratic residue: {}", aa);
            println!("a*a = x mod p");
            println!("a = {}", a);
            println!("x = {}", aa);

            break;
        }
    }
}

pub fn b_modular_math_legendre_symbol() {
    let p = &big!(101524035174539890485408575671085261788758965189060164484385690801466167356667036677932998889725476582421738788500738738503134356158197247473850273565349249573867251280253564698939768700489401960767007716413932851838937641880157263936985954881657889497583485535527613578457628399173971810541670838543309159139);

    let ints = "25081841204695904475894082974192007718642931811040324543182130088804239047149283334700530600468528298920930150221871666297194395061462592781551275161695411167049544771049769000895119729307495913024360169904315078028798025169985966732789207320203861858234048872508633514498384390497048416012928086480326832803, 45471765180330439060504647480621449634904192839383897212809808339619841633826534856109999027962620381874878086991125854247108359699799913776917227058286090426484548349388138935504299609200377899052716663351188664096302672712078508601311725863678223874157861163196340391008634419348573975841578359355931590555, 17364140182001694956465593533200623738590196990236340894554145562517924989208719245429557645254953527658049246737589538280332010533027062477684237933221198639948938784244510469138826808187365678322547992099715229218615475923754896960363138890331502811292427146595752813297603265829581292183917027983351121325, 14388109104985808487337749876058284426747816961971581447380608277949200244660381570568531129775053684256071819837294436069133592772543582735985855506250660938574234958754211349215293281645205354069970790155237033436065434572020652955666855773232074749487007626050323967496732359278657193580493324467258802863, 4379499308310772821004090447650785095356643590411706358119239166662089428685562719233435615196994728767593223519226235062647670077854687031681041462632566890129595506430188602238753450337691441293042716909901692570971955078924699306873191983953501093343423248482960643055943413031768521782634679536276233318, 85256449776780591202928235662805033201684571648990042997557084658000067050672130152734911919581661523957075992761662315262685030115255938352540032297113615687815976039390537716707854569980516690246592112936796917504034711418465442893323439490171095447109457355598873230115172636184525449905022174536414781771, 50576597458517451578431293746926099486388286246142012476814190030935689430726042810458344828563913001012415702876199708216875020997112089693759638454900092580746638631062117961876611545851157613835724635005253792316142379239047654392970415343694657580353333217547079551304961116837545648785312490665576832987, 96868738830341112368094632337476840272563704408573054404213766500407517251810212494515862176356916912627172280446141202661640191237336568731069327906100896178776245311689857997012187599140875912026589672629935267844696976980890380730867520071059572350667913710344648377601017758188404474812654737363275994871, 4881261656846638800623549662943393234361061827128610120046315649707078244180313661063004390750821317096754282796876479695558644108492317407662131441224257537276274962372021273583478509416358764706098471849536036184924640593888902859441388472856822541452041181244337124767666161645827145408781917658423571721, 18237936726367556664171427575475596460727369368246286138804284742124256700367133250078608537129877968287885457417957868580553371999414227484737603688992620953200143688061024092623556471053006464123205133894607923801371986027458274343737860395496260538663183193877539815179246700525865152165600985105257601565";
    let ints = ints.split(",");
    let ints = ints.map(|int_str| {
        let i = BigInt::parse_bytes(int_str.trim().as_bytes(), 10).unwrap();
        i
    });

    let _minus1 = &(p - 1);
    for (i, big_a) in ints.enumerate() {
        let legendre = &my_legendre_symbol(&big_a, p);

        //println!("legendre: {}", legendre);
        //use num_traits::Zero;
        use num_traits::One;

        if legendre.is_one() {
            println!("{}th int is a quadratic residue", i);
            println!("winner: {}", big_a);

            let root = big_a.modpow(&((p + 1) / 4), p);
            println!("root: {}", root);
        } else if legendre == _minus1 {
            println!("{}th int is a quadratic non-residue", i);
        } else {
            // zero
        }
    }
}

pub fn my_legendre_symbol(a: &BigInt, p: &BigInt) -> BigInt {
    //pow(a, (p-1)/2, p)

    let exp = (p - 1) / 2;
    let legendre = a.modpow(&exp, p);

    legendre
}

pub fn c_modular_math_modular_square_root() {    
    // let a = &big!(5);
    // let p = &big!(41);

    let a = &big!(8479994658316772151941616510097127087554541274812435112009425778595495359700244470400642403747058566807127814165396640215844192327900454116257979487432016769329970767046735091249898678088061634796559556704959846424131820416048436501387617211770124292793308079214153179977624440438616958575058361193975686620046439877308339989295604537867493683872778843921771307305602776398786978353866231661453376056771972069776398999013769588936194859344941268223184197231368887060609212875507518936172060702209557124430477137421847130682601666968691651447236917018634902407704797328509461854842432015009878011354022108661461024768);
    let p = &big!(30531851861994333252675935111487950694414332763909083514133769861350960895076504687261369815735742549428789138300843082086550059082835141454526618160634109969195486322015775943030060449557090064811940139431735209185996454739163555910726493597222646855506445602953689527405362207926990442391705014604777038685880527537489845359101552442292804398472642356609304810680731556542002301547846635101455995732584071355903010856718680732337369128498655255277003643669031694516851390505923416710601212618443109844041514942401969629158975457079026906304328749039997262960301209158175920051890620947063936347307238412281568760161);
    

    let root = my_tonelli_shanks(p, a);

    println!("root flag: {}", root);
}

pub fn my_tonelli_shanks(p: &BigInt, n: &BigInt) -> BigInt {
    use num_traits::One;
    use num_traits::Zero;

    let p_1 = p - 1;

    let (q, s) = my_factor_powers_2(&p_1);

    println!("q: {}", q);
    println!("s: {}", s);

    //let a1 =

    let z = my_find_non_residue(p);
    println!("z: {}", z);

    let mut m = s.clone();
    let mut c = z.modpow(&q, p);
    let mut t = n.modpow(&q, p);
    let mut r = n.modpow(&((&q + 1) / 2), p);

    for iter in 0..1000 {
        println!("--- iteration: {}", iter);
        println!("t: {}", t);
        println!("r: {}", r);
        println!("m: {}", m);
        if t.is_zero() {
            return BigInt::zero();
        } else if t.is_one() {
            return r;
        } else {
            let i = my_find_t_1_squaring(&m, &t, p);
            
            let b = (&m - &i - 1) % p;
            let b = (big!(2)).modpow(&b, p);
            //println!("2**(m - i - 1) == {}", &b);
            let b = &c.modpow(&b, p);
            //println!("b <- {}", b);

            m = i;
            c = b.modpow(&big!(2), p);
            //println!("c <- {}", c);
            
            t *= &c;
            t %= p;

            r *= b;
            r %= p;
        }
    }
    let root = BigInt::default();
    root
}

// returns i, 0 < i < m, such that t**(2**i) == 1
pub fn my_find_t_1_squaring(m: &BigInt, t: &BigInt, p: &BigInt) -> BigInt {
    use num_traits::One;

    println!("use repeated squaring to find the least i, 0 < i < M, such that t**(2**i) == 1");
    println!("M: {}", m);

    let mut i = BigInt::one();
    while &i < m {
        let squared = (&big!(2)).modpow(&i, p);
        let squared = t.modpow(&squared, p);

        if squared.is_one() {
            println!("found i: {}", i);

            break;
        }

        i += 1;
    }

    i
}

// returns (q, s)
// where x = q * 2**s
pub fn my_factor_powers_2(x: &BigInt) -> (BigInt, BigInt) {
    use num_integer::Integer;
    use num_traits::identities::Zero;

    let mut q = x.clone();
    let mut s = BigInt::zero();

    while q.is_even() {
        q = q / 2;

        s += 1;
    }
    //let s = BigInt::default();

    (q, s)
}

// return z, which is non-residue
pub fn my_find_non_residue(p: &BigInt) -> BigInt {
    let mut test: BigInt = big!(2);
    let _minus1 = &(p - 1);
    let legendre_exp = _minus1 / 2;

    loop {
        test += 1;

        let legendre = test.modpow(&legendre_exp, p);

        if &legendre == _minus1 {
            break;
        }
    }

    test
}

pub fn e_lattices_vectors() {
    use ultraviolet::vec::DVec3;

    let v = DVec3::new(2.0, 6.0, 3.0);
    let w = DVec3::new(1.0, 0.0, 0.0);
    let u = DVec3::new(7.0, 7.0, 2.0);

    let result = (3.0 * (2.0 * v - w)).geom(2.0 * u);

    // Czesc skalarna iloczynu geometrycznego = dot (inner) product
    let geometric_scalar = result.s;
    println!("result: {}", geometric_scalar);
}

pub fn f_lattices_size_basis() {
    use ultraviolet::vec::DVec4;
    let u = DVec4::new(4.0, 6.0, 2.0, 5.0);

    println!("magnitude: {:?}", u.mag());
    println!("magnitude_squared: {:?}", u.mag_sq());
}

pub fn g_lattices_gram_schmidt() {
    use ultraviolet::vec::DVec4;
    let v1 = DVec4::new(4.0, 1.0, 3.0, -1.0);
    let v2 = DVec4::new(2.0, 1.0, -3.0, 4.0);
    let v3 = DVec4::new(1.0, 0.0, -2.0, 7.0);
    let v4 = DVec4::new(6.0, 2.0, 9.0, -5.0);

    let vecs = vec![v1, v2, v3, v4];
    let mut uecs = vec![];
    uecs.push(vecs[0]);

    for i in 1..vecs.len() {
        let mut sum = DVec4::default();
        let v = vecs[i];
        for j in 0..i {
            let u = uecs[j];
            let mu_i_j = v.dot(u) / u.mag_sq();

            sum += mu_i_j * u;
        }
        let u = v - sum;
        uecs.push(u);
    }
    for u in &uecs {
        println!("{:+.5?}", u);
    }

    println!("{:?}", uecs[3].y);
    println!("{:.5?}", uecs[3].y);
}
